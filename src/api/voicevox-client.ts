// 
// Generated by @himenon/openapi-typescript-code-generator v1.0.11
// 
// OpenApi : 3.1.0
// 
// 


import { Schemas, Responses } from "../types/voicevox";
export interface Parameter$audio_query {
    text: string;
    speaker: number;
    core_version?: string;
}
export interface Response$audio_query$Status$200 {
    "application/json": Schemas.AudioQuery;
}
export interface Response$audio_query$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$audio_query_from_preset {
    text: string;
    preset_id: number;
    core_version?: string;
}
export interface Response$audio_query_from_preset$Status$200 {
    "application/json": Schemas.AudioQuery;
}
export interface Response$audio_query_from_preset$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$accent_phrases {
    text: string;
    speaker: number;
    is_kana?: boolean;
    core_version?: string;
}
export interface Response$accent_phrases$Status$200 {
    "application/json": Schemas.AccentPhrase[];
}
export interface Response$accent_phrases$Status$400 {
    "application/json": Schemas.ParseKanaBadRequest;
}
export interface Response$accent_phrases$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$mora_data {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$mora_data {
    "application/json": Schemas.AccentPhrase[];
}
export interface Response$mora_data$Status$200 {
    "application/json": Schemas.AccentPhrase[];
}
export interface Response$mora_data$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$mora_length {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$mora_length {
    "application/json": Schemas.AccentPhrase[];
}
export interface Response$mora_length$Status$200 {
    "application/json": Schemas.AccentPhrase[];
}
export interface Response$mora_length$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$mora_pitch {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$mora_pitch {
    "application/json": Schemas.AccentPhrase[];
}
export interface Response$mora_pitch$Status$200 {
    "application/json": Schemas.AccentPhrase[];
}
export interface Response$mora_pitch$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$synthesis {
    speaker: number;
    /** 疑問系のテキストが与えられたら語尾を自動調整する */
    enable_interrogative_upspeak?: boolean;
    core_version?: string;
}
export interface RequestBody$synthesis {
    "application/json": Schemas.AudioQuery;
}
export interface Response$synthesis$Status$200 {
    "audio/wav": string;
}
export interface Response$synthesis$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$cancellable_synthesis {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$cancellable_synthesis {
    "application/json": Schemas.AudioQuery;
}
export interface Response$cancellable_synthesis$Status$200 {
    "audio/wav": string;
}
export interface Response$cancellable_synthesis$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$multi_synthesis {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$multi_synthesis {
    "application/json": Schemas.AudioQuery[];
}
export interface Response$multi_synthesis$Status$200 {
    "application/zip": string;
}
export interface Response$multi_synthesis$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$sing_frame_audio_query {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$sing_frame_audio_query {
    "application/json": Schemas.Score;
}
export interface Response$sing_frame_audio_query$Status$200 {
    "application/json": Schemas.FrameAudioQuery;
}
export interface Response$sing_frame_audio_query$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$sing_frame_f0 {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$sing_frame_f0 {
    "application/json": Schemas.Body_sing_frame_f0_sing_frame_f0_post;
}
export interface Response$sing_frame_f0$Status$200 {
    "application/json": number[];
}
export interface Response$sing_frame_f0$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$sing_frame_volume {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$sing_frame_volume {
    "application/json": Schemas.Body_sing_frame_volume_sing_frame_volume_post;
}
export interface Response$sing_frame_volume$Status$200 {
    "application/json": number[];
}
export interface Response$sing_frame_volume$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$frame_synthesis {
    speaker: number;
    core_version?: string;
}
export interface RequestBody$frame_synthesis {
    "application/json": Schemas.FrameAudioQuery;
}
export interface Response$frame_synthesis$Status$200 {
    "audio/wav": string;
}
export interface Response$frame_synthesis$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface RequestBody$connect_waves {
    "application/json": string[];
}
export interface Response$connect_waves$Status$200 {
    "audio/wav": string;
}
export interface Response$connect_waves$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$validate_kana {
    /** 判定する対象の文字列 */
    text: string;
}
export interface Response$validate_kana$Status$200 {
    "application/json": boolean;
}
export interface Response$validate_kana$Status$400 {
    "application/json": Schemas.ParseKanaBadRequest;
}
export interface Response$validate_kana$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$initialize_speaker {
    speaker: number;
    /** 既に初期化済みのスタイルの再初期化をスキップするかどうか */
    skip_reinit?: boolean;
    core_version?: string;
}
export interface Response$initialize_speaker$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$is_initialized_speaker {
    speaker: number;
    core_version?: string;
}
export interface Response$is_initialized_speaker$Status$200 {
    "application/json": boolean;
}
export interface Response$is_initialized_speaker$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$supported_devices {
    core_version?: string;
}
export interface Response$supported_devices$Status$200 {
    "application/json": Schemas.SupportedDevicesInfo;
}
export interface Response$supported_devices$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$morphable_targets {
    core_version?: string;
}
export interface RequestBody$morphable_targets {
    "application/json": number[];
}
export interface Response$morphable_targets$Status$200 {
    "application/json": {
        [key: string]: Schemas.MorphableTargetInfo;
    }[];
}
export interface Response$morphable_targets$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$_synthesis_morphing {
    base_speaker: number;
    target_speaker: number;
    morph_rate: number;
    core_version?: string;
}
export interface RequestBody$_synthesis_morphing {
    "application/json": Schemas.AudioQuery;
}
export interface Response$_synthesis_morphing$Status$200 {
    "audio/wav": string;
}
export interface Response$_synthesis_morphing$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Response$get_presets$Status$200 {
    "application/json": Schemas.Preset[];
}
export interface RequestBody$add_preset {
    /** 新しいプリセット。プリセットIDが既存のものと重複している場合は、新規のプリセットIDが採番されます。 */
    "application/json": Schemas.Preset;
}
export interface Response$add_preset$Status$200 {
    "application/json": number;
}
export interface Response$add_preset$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface RequestBody$update_preset {
    /** 更新するプリセット。プリセットIDが更新対象と一致している必要があります。 */
    "application/json": Schemas.Preset;
}
export interface Response$update_preset$Status$200 {
    "application/json": number;
}
export interface Response$update_preset$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$delete_preset {
    /** 削除するプリセットのプリセットID */
    id: number;
}
export interface Response$delete_preset$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$speakers {
    core_version?: string;
}
export interface Response$speakers$Status$200 {
    "application/json": Schemas.Speaker[];
}
export interface Response$speakers$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$speaker_info {
    speaker_uuid: string;
    resource_format?: "base64" | "url";
    core_version?: string;
}
export interface Response$speaker_info$Status$200 {
    "application/json": Schemas.SpeakerInfo;
}
export interface Response$speaker_info$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$singers {
    core_version?: string;
}
export interface Response$singers$Status$200 {
    "application/json": Schemas.Speaker[];
}
export interface Response$singers$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$singer_info {
    speaker_uuid: string;
    resource_format?: "base64" | "url";
    core_version?: string;
}
export interface Response$singer_info$Status$200 {
    "application/json": Schemas.SpeakerInfo;
}
export interface Response$singer_info$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Response$get_user_dict_words$Status$200 {
    "application/json": {
        [key: string]: Schemas.UserDictWord;
    };
}
export interface Parameter$add_user_dict_word {
    /** 言葉の表層形 */
    surface: string;
    /** 言葉の発音（カタカナ） */
    pronunciation: string;
    /** アクセント型（音が下がる場所を指す） */
    accent_type: number;
    /** PROPER_NOUN（固有名詞）、COMMON_NOUN（普通名詞）、VERB（動詞）、ADJECTIVE（形容詞）、SUFFIX（語尾）のいずれか */
    word_type?: Schemas.WordTypes;
    /** 単語の優先度（0から10までの整数）。数字が大きいほど優先度が高くなる。1から9までの値を指定することを推奨 */
    priority?: number;
}
export interface Response$add_user_dict_word$Status$200 {
    "application/json": string;
}
export interface Response$add_user_dict_word$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$rewrite_user_dict_word {
    /** 更新する言葉のUUID */
    word_uuid: string;
    /** 言葉の表層形 */
    surface: string;
    /** 言葉の発音（カタカナ） */
    pronunciation: string;
    /** アクセント型（音が下がる場所を指す） */
    accent_type: number;
    /** PROPER_NOUN（固有名詞）、COMMON_NOUN（普通名詞）、VERB（動詞）、ADJECTIVE（形容詞）、SUFFIX（語尾）のいずれか */
    word_type?: Schemas.WordTypes;
    /** 単語の優先度（0から10までの整数）。数字が大きいほど優先度が高くなる。1から9までの値を指定することを推奨。 */
    priority?: number;
}
export interface Response$rewrite_user_dict_word$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$delete_user_dict_word {
    /** 削除する言葉のUUID */
    word_uuid: string;
}
export interface Response$delete_user_dict_word$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Parameter$import_user_dict_words {
    /** 重複したエントリがあった場合、上書きするかどうか */
    override: boolean;
}
export interface RequestBody$import_user_dict_words {
    /** インポートするユーザー辞書のデータ */
    "application/json": {
        [key: string]: Schemas.UserDictWord;
    };
}
export interface Response$import_user_dict_words$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Response$version$Status$200 {
    "application/json": string;
}
export interface Response$core_versions$Status$200 {
    "application/json": string[];
}
export interface Response$engine_manifest$Status$200 {
    "application/json": Schemas.EngineManifest;
}
export interface RequestBody$setting_post {
    "application/x-www-form-urlencoded": Schemas.Body_setting_post_setting_post;
}
export interface Response$setting_post$Status$422 {
    "application/json": Schemas.HTTPValidationError;
}
export interface Response$get_portal_page$Status$200 {
    "text/html": string;
}
export type ResponseContentType$audio_query = keyof Response$audio_query$Status$200;
export interface Params$audio_query {
    parameter: Parameter$audio_query;
}
export type ResponseContentType$audio_query_from_preset = keyof Response$audio_query_from_preset$Status$200;
export interface Params$audio_query_from_preset {
    parameter: Parameter$audio_query_from_preset;
}
export type ResponseContentType$accent_phrases = keyof Response$accent_phrases$Status$200;
export interface Params$accent_phrases {
    parameter: Parameter$accent_phrases;
}
export type RequestContentType$mora_data = keyof RequestBody$mora_data;
export type ResponseContentType$mora_data = keyof Response$mora_data$Status$200;
export interface Params$mora_data {
    parameter: Parameter$mora_data;
    requestBody: RequestBody$mora_data["application/json"];
}
export type RequestContentType$mora_length = keyof RequestBody$mora_length;
export type ResponseContentType$mora_length = keyof Response$mora_length$Status$200;
export interface Params$mora_length {
    parameter: Parameter$mora_length;
    requestBody: RequestBody$mora_length["application/json"];
}
export type RequestContentType$mora_pitch = keyof RequestBody$mora_pitch;
export type ResponseContentType$mora_pitch = keyof Response$mora_pitch$Status$200;
export interface Params$mora_pitch {
    parameter: Parameter$mora_pitch;
    requestBody: RequestBody$mora_pitch["application/json"];
}
export type RequestContentType$synthesis = keyof RequestBody$synthesis;
export type ResponseContentType$synthesis = keyof Response$synthesis$Status$200;
export interface Params$synthesis {
    parameter: Parameter$synthesis;
    requestBody: RequestBody$synthesis["application/json"];
}
export type RequestContentType$cancellable_synthesis = keyof RequestBody$cancellable_synthesis;
export type ResponseContentType$cancellable_synthesis = keyof Response$cancellable_synthesis$Status$200;
export interface Params$cancellable_synthesis {
    parameter: Parameter$cancellable_synthesis;
    requestBody: RequestBody$cancellable_synthesis["application/json"];
}
export type RequestContentType$multi_synthesis = keyof RequestBody$multi_synthesis;
export type ResponseContentType$multi_synthesis = keyof Response$multi_synthesis$Status$200;
export interface Params$multi_synthesis {
    parameter: Parameter$multi_synthesis;
    requestBody: RequestBody$multi_synthesis["application/json"];
}
export type RequestContentType$sing_frame_audio_query = keyof RequestBody$sing_frame_audio_query;
export type ResponseContentType$sing_frame_audio_query = keyof Response$sing_frame_audio_query$Status$200;
export interface Params$sing_frame_audio_query {
    parameter: Parameter$sing_frame_audio_query;
    requestBody: RequestBody$sing_frame_audio_query["application/json"];
}
export type RequestContentType$sing_frame_f0 = keyof RequestBody$sing_frame_f0;
export type ResponseContentType$sing_frame_f0 = keyof Response$sing_frame_f0$Status$200;
export interface Params$sing_frame_f0 {
    parameter: Parameter$sing_frame_f0;
    requestBody: RequestBody$sing_frame_f0["application/json"];
}
export type RequestContentType$sing_frame_volume = keyof RequestBody$sing_frame_volume;
export type ResponseContentType$sing_frame_volume = keyof Response$sing_frame_volume$Status$200;
export interface Params$sing_frame_volume {
    parameter: Parameter$sing_frame_volume;
    requestBody: RequestBody$sing_frame_volume["application/json"];
}
export type RequestContentType$frame_synthesis = keyof RequestBody$frame_synthesis;
export type ResponseContentType$frame_synthesis = keyof Response$frame_synthesis$Status$200;
export interface Params$frame_synthesis {
    parameter: Parameter$frame_synthesis;
    requestBody: RequestBody$frame_synthesis["application/json"];
}
export type RequestContentType$connect_waves = keyof RequestBody$connect_waves;
export type ResponseContentType$connect_waves = keyof Response$connect_waves$Status$200;
export interface Params$connect_waves {
    requestBody: RequestBody$connect_waves["application/json"];
}
export type ResponseContentType$validate_kana = keyof Response$validate_kana$Status$200;
export interface Params$validate_kana {
    parameter: Parameter$validate_kana;
}
export interface Params$initialize_speaker {
    parameter: Parameter$initialize_speaker;
}
export type ResponseContentType$is_initialized_speaker = keyof Response$is_initialized_speaker$Status$200;
export interface Params$is_initialized_speaker {
    parameter: Parameter$is_initialized_speaker;
}
export type ResponseContentType$supported_devices = keyof Response$supported_devices$Status$200;
export interface Params$supported_devices {
    parameter: Parameter$supported_devices;
}
export type RequestContentType$morphable_targets = keyof RequestBody$morphable_targets;
export type ResponseContentType$morphable_targets = keyof Response$morphable_targets$Status$200;
export interface Params$morphable_targets {
    parameter: Parameter$morphable_targets;
    requestBody: RequestBody$morphable_targets["application/json"];
}
export type RequestContentType$_synthesis_morphing = keyof RequestBody$_synthesis_morphing;
export type ResponseContentType$_synthesis_morphing = keyof Response$_synthesis_morphing$Status$200;
export interface Params$_synthesis_morphing {
    parameter: Parameter$_synthesis_morphing;
    requestBody: RequestBody$_synthesis_morphing["application/json"];
}
export type ResponseContentType$get_presets = keyof Response$get_presets$Status$200;
export type RequestContentType$add_preset = keyof RequestBody$add_preset;
export type ResponseContentType$add_preset = keyof Response$add_preset$Status$200;
export interface Params$add_preset {
    requestBody: RequestBody$add_preset["application/json"];
}
export type RequestContentType$update_preset = keyof RequestBody$update_preset;
export type ResponseContentType$update_preset = keyof Response$update_preset$Status$200;
export interface Params$update_preset {
    requestBody: RequestBody$update_preset["application/json"];
}
export interface Params$delete_preset {
    parameter: Parameter$delete_preset;
}
export type ResponseContentType$speakers = keyof Response$speakers$Status$200;
export interface Params$speakers {
    parameter: Parameter$speakers;
}
export type ResponseContentType$speaker_info = keyof Response$speaker_info$Status$200;
export interface Params$speaker_info {
    parameter: Parameter$speaker_info;
}
export type ResponseContentType$singers = keyof Response$singers$Status$200;
export interface Params$singers {
    parameter: Parameter$singers;
}
export type ResponseContentType$singer_info = keyof Response$singer_info$Status$200;
export interface Params$singer_info {
    parameter: Parameter$singer_info;
}
export type ResponseContentType$get_user_dict_words = keyof Response$get_user_dict_words$Status$200;
export type ResponseContentType$add_user_dict_word = keyof Response$add_user_dict_word$Status$200;
export interface Params$add_user_dict_word {
    parameter: Parameter$add_user_dict_word;
}
export interface Params$rewrite_user_dict_word {
    parameter: Parameter$rewrite_user_dict_word;
}
export interface Params$delete_user_dict_word {
    parameter: Parameter$delete_user_dict_word;
}
export type RequestContentType$import_user_dict_words = keyof RequestBody$import_user_dict_words;
export interface Params$import_user_dict_words {
    parameter: Parameter$import_user_dict_words;
    requestBody: RequestBody$import_user_dict_words["application/json"];
}
export type ResponseContentType$version = keyof Response$version$Status$200;
export type ResponseContentType$core_versions = keyof Response$core_versions$Status$200;
export type ResponseContentType$engine_manifest = keyof Response$engine_manifest$Status$200;
export type RequestContentType$setting_post = keyof RequestBody$setting_post;
export interface Params$setting_post {
    requestBody: RequestBody$setting_post["application/x-www-form-urlencoded"];
}
export type ResponseContentType$get_portal_page = keyof Response$get_portal_page$Status$200;
export type HttpMethod = "GET" | "PUT" | "POST" | "DELETE" | "OPTIONS" | "HEAD" | "PATCH" | "TRACE";
export interface ObjectLike {
    [key: string]: any;
}
export interface QueryParameter {
    value: any;
    style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    explode: boolean;
}
export interface QueryParameters {
    [key: string]: QueryParameter;
}
export type SuccessResponses = Response$audio_query$Status$200 | Response$audio_query_from_preset$Status$200 | Response$accent_phrases$Status$200 | Response$mora_data$Status$200 | Response$mora_length$Status$200 | Response$mora_pitch$Status$200 | Response$synthesis$Status$200 | Response$cancellable_synthesis$Status$200 | Response$multi_synthesis$Status$200 | Response$sing_frame_audio_query$Status$200 | Response$sing_frame_f0$Status$200 | Response$sing_frame_volume$Status$200 | Response$frame_synthesis$Status$200 | Response$connect_waves$Status$200 | Response$validate_kana$Status$200 | Response$is_initialized_speaker$Status$200 | Response$supported_devices$Status$200 | Response$morphable_targets$Status$200 | Response$_synthesis_morphing$Status$200 | Response$get_presets$Status$200 | Response$add_preset$Status$200 | Response$update_preset$Status$200 | Response$speakers$Status$200 | Response$speaker_info$Status$200 | Response$singers$Status$200 | Response$singer_info$Status$200 | Response$get_user_dict_words$Status$200 | Response$add_user_dict_word$Status$200 | Response$version$Status$200 | Response$core_versions$Status$200 | Response$engine_manifest$Status$200 | Response$get_portal_page$Status$200;
export namespace ErrorResponse {
    export type audio_query = Response$audio_query$Status$422;
    export type audio_query_from_preset = Response$audio_query_from_preset$Status$422;
    export type accent_phrases = Response$accent_phrases$Status$400 | Response$accent_phrases$Status$422;
    export type mora_data = Response$mora_data$Status$422;
    export type mora_length = Response$mora_length$Status$422;
    export type mora_pitch = Response$mora_pitch$Status$422;
    export type synthesis = Response$synthesis$Status$422;
    export type cancellable_synthesis = Response$cancellable_synthesis$Status$422;
    export type multi_synthesis = Response$multi_synthesis$Status$422;
    export type sing_frame_audio_query = Response$sing_frame_audio_query$Status$422;
    export type sing_frame_f0 = Response$sing_frame_f0$Status$422;
    export type sing_frame_volume = Response$sing_frame_volume$Status$422;
    export type frame_synthesis = Response$frame_synthesis$Status$422;
    export type connect_waves = Response$connect_waves$Status$422;
    export type validate_kana = Response$validate_kana$Status$400 | Response$validate_kana$Status$422;
    export type initialize_speaker = Response$initialize_speaker$Status$422;
    export type is_initialized_speaker = Response$is_initialized_speaker$Status$422;
    export type supported_devices = Response$supported_devices$Status$422;
    export type morphable_targets = Response$morphable_targets$Status$422;
    export type _synthesis_morphing = Response$_synthesis_morphing$Status$422;
    export type get_presets = void;
    export type add_preset = Response$add_preset$Status$422;
    export type update_preset = Response$update_preset$Status$422;
    export type delete_preset = Response$delete_preset$Status$422;
    export type speakers = Response$speakers$Status$422;
    export type speaker_info = Response$speaker_info$Status$422;
    export type singers = Response$singers$Status$422;
    export type singer_info = Response$singer_info$Status$422;
    export type get_user_dict_words = void;
    export type add_user_dict_word = Response$add_user_dict_word$Status$422;
    export type rewrite_user_dict_word = Response$rewrite_user_dict_word$Status$422;
    export type delete_user_dict_word = Response$delete_user_dict_word$Status$422;
    export type import_user_dict_words = Response$import_user_dict_words$Status$422;
    export type version = void;
    export type core_versions = void;
    export type engine_manifest = void;
    export type setting_get = void;
    export type setting_post = Response$setting_post$Status$422;
    export type get_portal_page = void;
}
export interface Encoding {
    readonly contentType?: string;
    headers?: Record<string, any>;
    readonly style?: "form" | "spaceDelimited" | "pipeDelimited" | "deepObject";
    readonly explode?: boolean;
    readonly allowReserved?: boolean;
}
export interface RequestArgs {
    readonly httpMethod: HttpMethod;
    readonly url: string;
    headers: ObjectLike | any;
    requestBody?: ObjectLike | any;
    requestBodyEncoding?: Record<string, Encoding>;
    queryParameters?: QueryParameters | undefined;
}
export interface ApiClient<RequestOption> {
    request: <T = SuccessResponses>(requestArgs: RequestArgs, options?: RequestOption) => Promise<T>;
}
export const createClient = <RequestOption>(apiClient: ApiClient<RequestOption>, baseUrl: string) => {
    const _baseUrl = baseUrl.replace(/\/$/, "");
    return {
        /**
         * 音声合成用のクエリを作成する
         * 音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま音声合成に利用できます。各値の意味は`Schemas`を参照してください。
         */
        audio_query: (params: Params$audio_query, option?: RequestOption): Promise<Response$audio_query$Status$200["application/json"]> => {
            const url = _baseUrl + `/audio_query`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                text: { value: params.parameter.text, explode: false },
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * 音声合成用のクエリをプリセットを用いて作成する
         * 音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま音声合成に利用できます。各値の意味は`Schemas`を参照してください。
         */
        audio_query_from_preset: (params: Params$audio_query_from_preset, option?: RequestOption): Promise<Response$audio_query_from_preset$Status$200["application/json"]> => {
            const url = _baseUrl + `/audio_query_from_preset`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                text: { value: params.parameter.text, explode: false },
                preset_id: { value: params.parameter.preset_id, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * テキストからアクセント句を得る
         * テキストからアクセント句を得ます。
         * is_kanaが`true`のとき、テキストは次のAquesTalk 風記法で解釈されます。デフォルトは`false`です。
         * * 全てのカナはカタカナで記述される
         * * アクセント句は`/`または`、`で区切る。`、`で区切った場合に限り無音区間が挿入される。
         * * カナの手前に`_`を入れるとそのカナは無声化される
         * * アクセント位置を`'`で指定する。全てのアクセント句にはアクセント位置を1つ指定する必要がある。
         * * アクセント句末に`？`(全角)を入れることにより疑問文の発音ができる。
         */
        accent_phrases: (params: Params$accent_phrases, option?: RequestOption): Promise<Response$accent_phrases$Status$200["application/json"]> => {
            const url = _baseUrl + `/accent_phrases`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                text: { value: params.parameter.text, explode: false },
                speaker: { value: params.parameter.speaker, explode: false },
                is_kana: { value: params.parameter.is_kana, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /** アクセント句から音高・音素長を得る */
        mora_data: (params: Params$mora_data, option?: RequestOption): Promise<Response$mora_data$Status$200["application/json"]> => {
            const url = _baseUrl + `/mora_data`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /** アクセント句から音素長を得る */
        mora_length: (params: Params$mora_length, option?: RequestOption): Promise<Response$mora_length$Status$200["application/json"]> => {
            const url = _baseUrl + `/mora_length`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /** アクセント句から音高を得る */
        mora_pitch: (params: Params$mora_pitch, option?: RequestOption): Promise<Response$mora_pitch$Status$200["application/json"]> => {
            const url = _baseUrl + `/mora_pitch`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /** 音声合成する */
        synthesis: (params: Params$synthesis, option?: RequestOption): Promise<Response$synthesis$Status$200["audio/wav"]> => {
            const url = _baseUrl + `/synthesis`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "audio/wav"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                enable_interrogative_upspeak: { value: params.parameter.enable_interrogative_upspeak, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /** 音声合成する（キャンセル可能） */
        cancellable_synthesis: (params: Params$cancellable_synthesis, option?: RequestOption): Promise<Response$cancellable_synthesis$Status$200["audio/wav"]> => {
            const url = _baseUrl + `/cancellable_synthesis`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "audio/wav"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /** 複数まとめて音声合成する */
        multi_synthesis: (params: Params$multi_synthesis, option?: RequestOption): Promise<Response$multi_synthesis$Status$200["application/zip"]> => {
            const url = _baseUrl + `/multi_synthesis`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/zip"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * 歌唱音声合成用のクエリを作成する
         * 歌唱音声合成用のクエリの初期値を得ます。ここで得られたクエリはそのまま歌唱音声合成に利用できます。各値の意味は`Schemas`を参照してください。
         */
        sing_frame_audio_query: (params: Params$sing_frame_audio_query, option?: RequestOption): Promise<Response$sing_frame_audio_query$Status$200["application/json"]> => {
            const url = _baseUrl + `/sing_frame_audio_query`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /** 楽譜・歌唱音声合成用のクエリからフレームごとの基本周波数を得る */
        sing_frame_f0: (params: Params$sing_frame_f0, option?: RequestOption): Promise<Response$sing_frame_f0$Status$200["application/json"]> => {
            const url = _baseUrl + `/sing_frame_f0`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /** 楽譜・歌唱音声合成用のクエリからフレームごとの音量を得る */
        sing_frame_volume: (params: Params$sing_frame_volume, option?: RequestOption): Promise<Response$sing_frame_volume$Status$200["application/json"]> => {
            const url = _baseUrl + `/sing_frame_volume`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Frame Synthesis
         * 歌唱音声合成を行います。
         */
        frame_synthesis: (params: Params$frame_synthesis, option?: RequestOption): Promise<Response$frame_synthesis$Status$200["audio/wav"]> => {
            const url = _baseUrl + `/frame_synthesis`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "audio/wav"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * base64エンコードされた複数のwavデータを一つに結合する
         * base64エンコードされたwavデータを一纏めにし、wavファイルで返します。
         */
        connect_waves: (params: Params$connect_waves, option?: RequestOption): Promise<Response$connect_waves$Status$200["audio/wav"]> => {
            const url = _baseUrl + `/connect_waves`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "audio/wav"
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody
            }, option);
        },
        /**
         * テキストがAquesTalk 風記法に従っているか判定する
         * テキストがAquesTalk 風記法に従っているかどうかを判定します。
         * 従っていない場合はエラーが返ります。
         */
        validate_kana: (params: Params$validate_kana, option?: RequestOption): Promise<Response$validate_kana$Status$200["application/json"]> => {
            const url = _baseUrl + `/validate_kana`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                text: { value: params.parameter.text, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Initialize Speaker
         * 指定されたスタイルを初期化します。
         * 実行しなくても他のAPIは使用できますが、初回実行時に時間がかかることがあります。
         */
        initialize_speaker: (params: Params$initialize_speaker, option?: RequestOption): Promise<void> => {
            const url = _baseUrl + `/initialize_speaker`;
            const headers = {};
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                skip_reinit: { value: params.parameter.skip_reinit, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Is Initialized Speaker
         * 指定されたスタイルが初期化されているかどうかを返します。
         */
        is_initialized_speaker: (params: Params$is_initialized_speaker, option?: RequestOption): Promise<Response$is_initialized_speaker$Status$200["application/json"]> => {
            const url = _baseUrl + `/is_initialized_speaker`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker: { value: params.parameter.speaker, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Supported Devices
         * 対応デバイスの一覧を取得します。
         */
        supported_devices: (params: Params$supported_devices, option?: RequestOption): Promise<Response$supported_devices$Status$200["application/json"]> => {
            const url = _baseUrl + `/supported_devices`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * 指定したスタイルに対してエンジン内のキャラクターがモーフィングが可能か判定する
         * 指定されたベーススタイルに対してエンジン内の各キャラクターがモーフィング機能を利用可能か返します。
         * モーフィングの許可/禁止は`/speakers`の`speaker.supported_features.synthesis_morphing`に記載されています。
         * プロパティが存在しない場合は、モーフィングが許可されているとみなします。
         * 返り値のスタイルIDはstring型なので注意。
         */
        morphable_targets: (params: Params$morphable_targets, option?: RequestOption): Promise<Response$morphable_targets$Status$200["application/json"]> => {
            const url = _baseUrl + `/morphable_targets`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * 2種類のスタイルでモーフィングした音声を合成する
         * 指定された2種類のスタイルで音声を合成、指定した割合でモーフィングした音声を得ます。
         * モーフィングの割合は`morph_rate`で指定でき、0.0でベースのスタイル、1.0でターゲットのスタイルに近づきます。
         */
        _synthesis_morphing: (params: Params$_synthesis_morphing, option?: RequestOption): Promise<Response$_synthesis_morphing$Status$200["audio/wav"]> => {
            const url = _baseUrl + `/synthesis_morphing`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "audio/wav"
            };
            const queryParameters: QueryParameters = {
                base_speaker: { value: params.parameter.base_speaker, explode: false },
                target_speaker: { value: params.parameter.target_speaker, explode: false },
                morph_rate: { value: params.parameter.morph_rate, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Get Presets
         * エンジンが保持しているプリセットの設定を返します
         */
        get_presets: (option?: RequestOption): Promise<Response$get_presets$Status$200["application/json"]> => {
            const url = _baseUrl + `/presets`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        /**
         * Add Preset
         * 新しいプリセットを追加します
         */
        add_preset: (params: Params$add_preset, option?: RequestOption): Promise<Response$add_preset$Status$200["application/json"]> => {
            const url = _baseUrl + `/add_preset`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody
            }, option);
        },
        /**
         * Update Preset
         * 既存のプリセットを更新します
         */
        update_preset: (params: Params$update_preset, option?: RequestOption): Promise<Response$update_preset$Status$200["application/json"]> => {
            const url = _baseUrl + `/update_preset`;
            const headers = {
                "Content-Type": "application/json",
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody
            }, option);
        },
        /**
         * Delete Preset
         * 既存のプリセットを削除します
         */
        delete_preset: (params: Params$delete_preset, option?: RequestOption): Promise<void> => {
            const url = _baseUrl + `/delete_preset`;
            const headers = {};
            const queryParameters: QueryParameters = {
                id: { value: params.parameter.id, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Speakers
         * 喋れるキャラクターの情報の一覧を返します。
         */
        speakers: (params: Params$speakers, option?: RequestOption): Promise<Response$speakers$Status$200["application/json"]> => {
            const url = _baseUrl + `/speakers`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Speaker Info
         * UUID で指定された喋れるキャラクターの情報を返します。
         * 画像や音声はresource_formatで指定した形式で返されます。
         */
        speaker_info: (params: Params$speaker_info, option?: RequestOption): Promise<Response$speaker_info$Status$200["application/json"]> => {
            const url = _baseUrl + `/speaker_info`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker_uuid: { value: params.parameter.speaker_uuid, explode: false },
                resource_format: { value: params.parameter.resource_format, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Singers
         * 歌えるキャラクターの情報の一覧を返します。
         */
        singers: (params: Params$singers, option?: RequestOption): Promise<Response$singers$Status$200["application/json"]> => {
            const url = _baseUrl + `/singers`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Singer Info
         * UUID で指定された歌えるキャラクターの情報を返します。
         * 画像や音声はresource_formatで指定した形式で返されます。
         */
        singer_info: (params: Params$singer_info, option?: RequestOption): Promise<Response$singer_info$Status$200["application/json"]> => {
            const url = _baseUrl + `/singer_info`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                speaker_uuid: { value: params.parameter.speaker_uuid, explode: false },
                resource_format: { value: params.parameter.resource_format, explode: false },
                core_version: { value: params.parameter.core_version, explode: false }
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Get User Dict Words
         * ユーザー辞書に登録されている単語の一覧を返します。
         * 単語の表層形(surface)は正規化済みの物を返します。
         */
        get_user_dict_words: (option?: RequestOption): Promise<Response$get_user_dict_words$Status$200["application/json"]> => {
            const url = _baseUrl + `/user_dict`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        /**
         * Add User Dict Word
         * ユーザー辞書に言葉を追加します。
         */
        add_user_dict_word: (params: Params$add_user_dict_word, option?: RequestOption): Promise<Response$add_user_dict_word$Status$200["application/json"]> => {
            const url = _baseUrl + `/user_dict_word`;
            const headers = {
                Accept: "application/json"
            };
            const queryParameters: QueryParameters = {
                surface: { value: params.parameter.surface, explode: false },
                pronunciation: { value: params.parameter.pronunciation, explode: false },
                accent_type: { value: params.parameter.accent_type, explode: false },
                word_type: { value: params.parameter.word_type, explode: false },
                priority: { value: params.parameter.priority, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Rewrite User Dict Word
         * ユーザー辞書に登録されている言葉を更新します。
         */
        rewrite_user_dict_word: (params: Params$rewrite_user_dict_word, option?: RequestOption): Promise<void> => {
            const url = _baseUrl + `/user_dict_word/${encodeURIComponent(params.parameter.word_uuid)}`;
            const headers = {};
            const queryParameters: QueryParameters = {
                surface: { value: params.parameter.surface, explode: false },
                pronunciation: { value: params.parameter.pronunciation, explode: false },
                accent_type: { value: params.parameter.accent_type, explode: false },
                word_type: { value: params.parameter.word_type, explode: false },
                priority: { value: params.parameter.priority, explode: false }
            };
            return apiClient.request({
                httpMethod: "PUT",
                url,
                headers,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Delete User Dict Word
         * ユーザー辞書に登録されている言葉を削除します。
         */
        delete_user_dict_word: (params: Params$delete_user_dict_word, option?: RequestOption): Promise<void> => {
            const url = _baseUrl + `/user_dict_word/${encodeURIComponent(params.parameter.word_uuid)}`;
            const headers = {};
            return apiClient.request({
                httpMethod: "DELETE",
                url,
                headers
            }, option);
        },
        /**
         * Import User Dict Words
         * 他のユーザー辞書をインポートします。
         */
        import_user_dict_words: (params: Params$import_user_dict_words, option?: RequestOption): Promise<void> => {
            const url = _baseUrl + `/import_user_dict`;
            const headers = {
                "Content-Type": "application/json"
            };
            const queryParameters: QueryParameters = {
                override: { value: params.parameter.override, explode: false }
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody,
                queryParameters: queryParameters
            }, option);
        },
        /**
         * Version
         * エンジンのバージョンを取得します。
         */
        version: (option?: RequestOption): Promise<Response$version$Status$200["application/json"]> => {
            const url = _baseUrl + `/version`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        /**
         * Core Versions
         * 利用可能なコアのバージョン一覧を取得します。
         */
        core_versions: (option?: RequestOption): Promise<Response$core_versions$Status$200["application/json"]> => {
            const url = _baseUrl + `/core_versions`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        /**
         * Engine Manifest
         * エンジンマニフェストを取得します。
         */
        engine_manifest: (option?: RequestOption): Promise<Response$engine_manifest$Status$200["application/json"]> => {
            const url = _baseUrl + `/engine_manifest`;
            const headers = {
                Accept: "application/json"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        /**
         * Setting Get
         * 設定ページを返します。
         */
        setting_get: (option?: RequestOption): Promise<void> => {
            const url = _baseUrl + `/setting`;
            const headers = {};
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        },
        /**
         * Setting Post
         * 設定を更新します。
         */
        setting_post: (params: Params$setting_post, option?: RequestOption): Promise<void> => {
            const url = _baseUrl + `/setting`;
            const headers = {
                "Content-Type": "application/x-www-form-urlencoded"
            };
            return apiClient.request({
                httpMethod: "POST",
                url,
                headers,
                requestBody: params.requestBody
            }, option);
        },
        /**
         * Get Portal Page
         * ポータルページを返します。
         */
        get_portal_page: (option?: RequestOption): Promise<Response$get_portal_page$Status$200["text/html"]> => {
            const url = _baseUrl + `/`;
            const headers = {
                Accept: "text/html"
            };
            return apiClient.request({
                httpMethod: "GET",
                url,
                headers
            }, option);
        }
    };
};
type ClientFunction<RequestOption> = typeof createClient<RequestOption>;
export type Client<RequestOption> = ReturnType<ClientFunction<RequestOption>>;
